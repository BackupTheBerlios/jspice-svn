{\rtf1 \mac \ansicpg437 \cocoartf102 {\fonttbl {\f0 \fnil \fcharset77 Times New Roman{\*\falt Times}
;}
{\f1 \fnil \fcharset77 LucidaGrande{\*\falt Lucida Grande}
;}
{\f2 \fnil \fcharset77 Helvetica;}
{\f3 \fnil \fcharset77 Monaco;}
{\f4 \fnil \fcharset77 TimesNewRomanPSMT{\*\falt Times New Roman}
;}
}
{\colortbl ;\red0 \green0 \blue0 ;}
{\stylesheet {\s36 \nisusnoteplacement1 \nisusreferencestyle37 \sbasedon38 {\*\nsmpltxt Sample text for Foot/End Notes Style}
\f1 Endnote;}
{\*\cs37 {\*\nsmpltxt The quick brown fox jumped over the lazy dogs.}
\super endnote reference;}
{\s38 \snext38 {\*\nsmpltxt Some text goes here so you can see what your style will look like.}
{\*\keycode \ncmd `}
\f1 \fs24 \cf1 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 Normal;}
{\s39 \nisusnoteplacement0 \nisusreferencestyle40 \sbasedon38 {\*\nsmpltxt Sample text for Foot/End Notes Style}
Footnote;}
{\*\cs40 {\*\nsmpltxt The quick brown fox jumped over the lazy dogs.}
\super footnote reference;}
{\s41 \nisusnoteplacement2 \nisusreferencestyle37 \sbasedon38 {\*\nsmpltxt Sample text for Foot/End Notes Style}
Endnote;}
{\s42 \snext38 \sbasedon38 {\*\nsmpltxt Some text goes here so you can see what your style will look like}
{\*\keycode \ncmd \fn1 }
\f2 \fs28 \b \sb120 \sa0 Heading 1;}
{\s43 \snext38 \sbasedon42 {\*\nsmpltxt Some text goes here so you can see what your style will look like }
{\*\keycode \ncmd \fn2 }
\fs26 Heading 2;}
{\s44 \snext38 \sbasedon43 {\*\nsmpltxt Some text goes here so you can see what your style will look like }
{\*\keycode \ncmd \fn3 }
\b0 \ul Heading 3;}
{\s45 \snext45 \sbasedon38 {\*\nsmpltxt Some text goes here so you can see what your style will look like.}
\sa0 Header;}
{\s46 \snext38 \sbasedon38 {\*\nsmpltxt Some text goes here so you can see what your style will look like.}
\f2 \fs28 \b \qc \sa0 Title;}
{\s47 \snext47 \sbasedon38 {\*\nsmpltxt Some text goes here so you can see what your style will look like.}
\sa0 Footer;}
{\s48 \snext48 \sbasedon38 {\*\nsmpltxt Some text goes here so you can see what your style will look like.}
\li1080 \fi0 \ri1020 Block Quote;}
{\s49 \snext49 \sbasedon38 {\*\nsmpltxt 1.}
\sa60 \li720 \fi-360 \ri0 List;}
{\*\cs50 \sbasedon51 {\*\nsmpltxt The quick brown fox jumped over the lazy dogs.}
\b \i Emphatic;}
{\*\cs51 {\*\nsmpltxt The quick brown fox jumped over the lazy dogs.}
\f4 Basic Character;}
{\s52 \snext52 \sbasedon38 {\*\nsmpltxt Some text goes here so you can see what your style will look like.}
{\*\keycode \ncmd 1}
\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
\ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 Code;}
{\*\cs53 {\*\nsmpltxt The quick brown fox jumped over the lazy dogs.}
{\*\keycode \ncmd 2}
\f3 \fs20 {\*\nisuslang X-TechEmail}
CodeStyle;}
}
{\*\nisuslangtbl {\nisuslang0 Tech - Email\code X-TechEmail}
}
\deftab720 \defformat \viewkind1 \viewscale100 {\*\nisuswindow \x49 \y123 \w821 \h867 }
\nshwinv1 \nshwpg1 \hyphauto0 \paperw12240 \paperh15840 \margl1440 \margr1440 \margt1800 \margb1800 \gutter0 \pgnstart1 \nocolbal \sectd \sbkpage \cols1 \ltrsect \colbalsxn0 \marglsxn1440 \margrsxn1440 \margtsxn1800 \margbsxn1800 \guttersxn0 \headery720 \footery720 \pgnstarts1 \pgnrestart \pgndec \sxnstarts1 \sxnrestart \sxndec {\header \pard \s45 \ql \sb0 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 \f1 \fs24 \cf1 \par }
{\footer \pard \s47 \ql \sb0 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 \f1 \fs24 \cf1 \par }
{\pard \s42 \qc \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs28 \b \ul \cf1 User Guide for the org.openspice.jspice.office Package}
{\f2 \fs28 \b \cf1 \par
}
}
{\pard \s42 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs28 \b \cf1 \par
}
}
{\pard \s38 \qr \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs20 \cf1 Document Version 1.2\par
Stephen Leach, Dec 2004\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
}
{\pard \s43 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b \cf1 [1] Introduction\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
The org.openspice.jspice.office package provides support for writing message oriented programs.  That means it provides a programming architecture (or metaphor) based on independent agents communicating asynchronously via messages.  As there is already a concerted attempt to develop an enterprise-level framework JMS, see http://java.sun.com/products/jms/overview.html, so why develop another?\par
When I looked at JMS I was disappointed.  My impression was that the work was quite immature, overblown and documented in such a jargon-intensive fashion as to make it inaccessible, at least to me.  Perhaps these issues will be ironed out in time.  However, it is not obvious why this simple programming technique needs such overkill.  In strong contrast, this package is lightweight and easy to understand and extend.\par
It is entirely possible that JMS will make this work redundant in the near future.\par
\par
}
}
{\pard \s43 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b \cf1 [2] The Metaphor\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
The metaphor used by the package is that of a busy office.  The office is staffed by many workers who coordinate their work by sending and receiving letters from both the outside world and each other.  Workers have names and roles.  The office will find a worker by name or role when asked.\par
A letter has only three mandatory fields: the subject, the from field and the to field.  The contents of the letter are built up either by appending values (like a list) or associating values with keys.  A worker is free to interpret these fields as they will.\par
Each worker has an in-tray for receiving letters and some (zero or more) out-trays for sending letters.  The workers always process their incoming letters in the sequence they arrived.  This processing typically causes further letters to be written and inserted into the out-trays.  When a letter is put into an out-tray it is immediately copied to all the connected in-trays.  Out-trays are named in the same way as workers.\par
For example, if a worker Bob should always be notified about a worker Alice\rquote s work, then Alice\rquote s out-tray should be connected to Bob\rquote s in-tray.  Many workers\rquote  in-trays may be connected to a single out-tray.  Every time a letter is put in the out-tray, the connected in-trays automatically receive a copy.\par
Alternatively, if Alice dynamically decides who the out-going letter should be sent to, then she will explicitly address the letter to a particular worker.  That way it will bypass the out-tray system completely.  A common example of this is a simple reply; replying means addressing a letter to the sender of the letter being processed.\par
When the last message has been sent to a worker they should be told to finish-off.  The worker will immediately close its in-tray, refusing further messages, process all outstanding letters and then close all out-trays. \par
Workers such as Alice and Bob can be implemented in several different ways.  They could be lightweight objects, middleweight threads, or heavyweight processes.  It doesn\rquote t matter as the classes are thread safe.\par
\par
}
}
{\pard \s43 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b \cf1 [3] Representing the Metaphor with Classes and Methods\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class Office\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
The office is represented by the class }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Office}
{\f1 \fs24 \cf1 .  To create one of these you invoke the constructor:\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
\par
//  Also, consider giving the office a name to help with debugging.\par
Office office = new Office();\par
office.setName( \ldblquote head office\rdblquote  );    // optional\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
An office has workers.  To find a worker by name or role, you use the }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
findByName}
{\f1 \fs24 \cf1  or }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
findByRole}
{\f1 \fs24 \cf1  methods of }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Office}
{\f1 \fs24 \cf1 .\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Worker w1 = office.findByName( \ldblquote fred\rdblquote  );\par
Worker w2 = office.findByRole( \ldblquote clerk\rdblquote  );\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
The office is also responsible for maintaining a thread, called the \ldblquote automatic\rdblquote  thread, which is used to process letters by \ldblquote automatic\rdblquote  workers.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Office\par
Thread getAutomaticThread()}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 \tx380 {\f1 \fs24 \cf1 \par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \ul \cf1 \par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class Worker\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
There are several types of worker which all inherit from the abstract class }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Worker}
{\f1 \fs24 \cf1 .  The main different types of worker are }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
MethodWorker}
{\f1 \fs24 \cf1 , }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
ReaderWriterWorker}
{\f1 \fs24 \cf1 , }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
SocketWorker}
{\f1 \fs24 \cf1 , and }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
ProcessWorker}
{\f1 \fs24 \cf1 .  They are distinguished by what facility they utilize to process their letters.  All workers must be passed the office to which they report.  e.g.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Worker\par
//  A ProcessWorker utilizes a java.lang.Process to process letters.\par
Process process = }
{\f3 \fs20 \i \cf1 {\*\nisuslang X-TechEmail}
some expression}
{\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
;\par
//  Also, consider giving the worker a name and role.\par
ProcessWorker p = new ProcessWorker( office, process );\par
p.setRole( \ldblquote clerk\rdblquote  );       // optional\par
p.setName( \ldblquote fred\rdblquote  );        // optional\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
A worker has a single in-tray and multiple out-trays.  You can retrieve these using the }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
getInTray}
{\f1 \fs24 \cf1  and }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
getOutTray}
{\f1 \fs24 \cf1  methods.  Note that }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
getOutTray}
{\f1 \fs24 \cf1  is a convenience method insofar that if no out-tray exists, it will create it with a default name of the empty string, otherwise it returns the first one added.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Worker\par
InTray getInTray()\par
OutTray getOutTray()                //  gets the default out-tray &\par
                                    //  creates if needed (first added)\par
OutTray getOutTray( String name )   //  gets a named out-tray\par
List allOutTray()                    //  gets all out-trays\par
OutTray newOutTray( String name )   //  makes a new out-tray}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 \tx380 {\f1 \fs24 \cf1 \par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
You can connect one worker to another worker or tray using the }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
connectTo}
{\f1 \fs24 \cf1  methods.  Naturally enough you can disconnect then with the }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
disconnectFrom}
{\f1 \fs24 \cf1  methods.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Worker\par
void connectTo( Worker dst )\par
void connectTo( Tray t )\par
void disconnectFrom( Worker dst )\par
void disconnectFrom( Tray t )\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
When no more letters will be sent to a worker, they are told to }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
finishOff}
{\f1 \fs24 \cf1 .  The worker will immediately close its in-tray, continue to process all pending letters, when no more letters remain it will then close all its out-trays.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Worker\par
void finishOff()            // OK to call this more than once\par
boolean isFinished()       \par
boolean isFinishing()}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 \tx380 {\f1 \fs24 \cf1 \par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
As the out-trays are closed, they automatically disconnect.  This may cause an in-tray to lose its one and only connection.  In that situation you may wish the owner of the in-tray to recursively }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
finishOff}
{\f1 \fs24 \cf1  as well.  You may set this option using the }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
finishOffOnLastDisconnect}
{\f1 \fs24 \cf1  method.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx1120 {\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Worker\par
boolean isFinishOffOnLastDisconnect()\par
void setFinishOffOnLastDisconnect( boolean f )\par
Worker finishOffOnLastDisconnect()       // sets flag to true}
{\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
\par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class Letter\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
Letters are represented by the class }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Letter}
{\f1 \fs24 \cf1 .  You can create them explicitly from one of }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Letter\rquote s}
{\f1 \fs24 \cf1  constructors.  Alternatively, and more conveniently, you can create them from a }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Worker}
{\f1 \fs24 \cf1  by one of these methods:\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Letter\par
Letter( Tray from, Tray to, Object subject )\par
Letter( Worker from, Worker to, Object subject )\par
\par
class Worker\par
Letter newOutTrayLetter( OutTray to, Object subject )\par
Letter newOutTrayLetter( Object subject )\par
Letter newReplyTo( Letter letter, Object subject )\par
Letter newLetterTo( Worker to, Object subject )\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
You get access to their fields using\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Letter\par
Tray getFrom()\par
Tray getTo()\par
Object getSubject()\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
Note that although the subject is typed as }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Object}
{\f1 \fs24 \cf1  not all instances are acceptable.  In actual fact, only }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
String}
{\f1 \fs24 \cf1  and }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Method}
{\f1 \fs24 \cf1  are allowed by default.\par
To append or associate content with a }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Letter}
{\f1 \fs24 \cf1 , use the add and put methods.  The add methods append positional data and the put methods insert keyed data.  It is up to you which ones you use.  To retrieve the content use the get methods.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Letter\par
Letter add( final Object value );\par
Letter put( final Object key, final Object value );\par
Object get()                   //  equivalent to get( 0 )\par
Object get( int index )        //  gets positional data\par
Object get( Object key )       //  gets keyed data\par
Object[] posnArray()           //  all positional values as an Array\par
List posnList()                //  all positional values as a List\par
Map keyedMap()                 //  all keyed values\par
int posnSize()                 //  number of positional values\par
int keyedSize()                //  number of keyed valued\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
When a letter is ready for sending, it may be sent to its destination by calling the method send.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class Letter\par
void send()\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
Note that this is equivalent to invoking }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
sendOne}
{\f1 \fs24 \cf1  on the destination tray.  i.e.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
letter.getTo().sendOne( letter );}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 \tx380 {\f1 \fs24 \cf1 \par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class Tray\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
This is the superclass of both }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
InTray}
{\f1 \fs24 \cf1  and }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
OutTray}
{\f1 \fs24 \cf1 .  Either type of tray is prepared to be sent messages via }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
sendOne}
{\f1 \fs24 \cf1  or }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
sendMany}
{\f1 \fs24 \cf1 .\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
void sendOne( Letter letter )\par
void sendMany( List letterList )\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Trays}
{\f1 \fs24 \cf1  are not open indefinitely.  When there is no more work to be done, they are told to close.  Typically this is done by the }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Worker}
{\f1 \fs24 \cf1  who owns the tray in reaction to being told to }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
finishOff}
{\f1 \fs24 \cf1 .\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
void close()\par
boolean isOpen()\par
boolean isClosed()\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class InTray (extends Tray)\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
There are two main types of in-tray: }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
AutomaticInTray}
{\f1 \fs24 \cf1  and }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
ThreadInTray}
{\f1 \fs24 \cf1 .  The former is used when the responsibility for handling incoming letters is given to the tray\rquote s worker.  The latter is used when the incoming letters is to be handled by an independent thread.\par
In-trays are always associated with a worker that \ldblquote owns\rdblquote  the in-tray.  This can be retrieved with method }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
getOwner}
{\f1 \fs24 \cf1 .\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Worker getOwner()\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class AutomaticInTray (extends InTray)\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
An automatic in-tray passes incoming letters to its worker, which will be an }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
AutomaticWorker}
{\f1 \fs24 \cf1 , via its }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
handleLetter}
{\f1 \fs24 \cf1  method.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class AutomaticWorker\par
void handleLetter( final Letter letter )\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
The subtle aspect to this is that an \ldblquote automatic\rdblquote  in-tray arranges for }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
handleLetter}
{\f1 \fs24 \cf1  to be called in the office\rquote s \ldblquote automatic\rdblquote  thread.  This makes it safe for arbitrary threads to send letters to automatic workers.\par
\par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class ThreadInTray (extends InTray)\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
This kind of in-tray simply queues the incoming messages for later removal by the receive method.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
class ThreadInTray\par
Letter receive()\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
It is perfectly safe for different threads to be adding and removing letters from this in-tray at the same time.\par
\par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 Class OutTray (extends Tray)\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
Out-trays simply forward their letters to the trays to which they are connected.  Note that it is possible to connect an out-tray to another out-tray if you like.\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
void connectTo( Tray tray )\par
void disconnectFrom( Tray tray )\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
An out-tray typically has an owner.  However, it is perfectly sensible to have out-trays without an owner.  The prefix \lquote try\rquote  means that }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
tryGetOwner}
{\f1 \fs24 \cf1  may return }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
null}
{\f1 \fs24 \cf1 .\par
\par
}
}
{\pard \s52 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi560 \ri0 \tx380 {\f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
Worker tryGetOwner()\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
}
{\pard \s43 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b \cf1 [4] Examples\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 [4.1] Examples\par
\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 There are several examples in the package\par
\tab  }
{\cs53 \f3 \fs20 \cf1 {\*\nisuslang X-TechEmail}
org.openspice.jspice.office.examples}
{\f1 \fs24 \cf1  \par
that are documented in Javadoc format.\par
\par
\par
}
}
{\pard \s44 \ql \sb120 \sa0 \sl240 \slmult1 \li0 \fi0 \ri0 {\f2 \fs26 \b0 \ul \cf1 [4.2] Integrating with Swing\par
}
}
{\pard \s38 \ql \sb0 \sa120 \sl240 \slmult1 \li0 \fi0 \ri0 {\f1 \fs24 \cf1 \par
Swing GUI processes are going to be a bit more challenging.  I don\rquote t know a lot about the way GUI\rquote s\par
work with threads.  Looks like I need SwingUtilities.invokeLater( Runnable ) to be invoked when\par
letters are available.  The notification of letter arrival can be generalized by the Observer/Observable\par
model.  I note that this has to be thread-safe.  Is Observer notification thread-safe? }
}
}
